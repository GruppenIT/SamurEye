#!/bin/bash

# ============================================================================
# SAMUREYE ON-PREMISE - HARD RESET COLLECTOR AGENT (vlxsam04)
# ============================================================================
# Sistema completo de reset e reinstala√ß√£o do Agente Coletor SamurEye
# Inclui: Python + Node.js + Security Tools + Collector Agent + Automation
#
# Servidor: vlxsam04 (192.168.100.151)
# Fun√ß√£o: Agente Coletor de Dados e Ferramentas de Seguran√ßa
# Depend√™ncias: vlxsam02 (API), vlxsam01 (Certificates)
# ============================================================================

set -e

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Fun√ß√µes de log
log() { echo -e "${GREEN}[$(date '+%H:%M:%S')] $1${NC}"; }
warn() { echo -e "${YELLOW}[$(date '+%H:%M:%S')] WARNING: $1${NC}"; }
error() { echo -e "${RED}[$(date '+%H:%M:%S')] ERROR: $1${NC}"; exit 1; }
info() { echo -e "${BLUE}[$(date '+%H:%M:%S')] INFO: $1${NC}"; }

# Verificar se est√° sendo executado como root
if [ "$EUID" -ne 0 ]; then
    error "Execute como root: sudo $0"
fi

# Configura√ß√µes do ambiente
COLLECTOR_USER="samureye-collector"
COLLECTOR_DIR="/opt/samureye/collector"
TOOLS_DIR="$COLLECTOR_DIR/tools"
CERTS_DIR="$COLLECTOR_DIR/certs"
CONFIG_DIR="/etc/samureye-collector"
SERVICE_NAME="samureye-collector"
PYTHON_VERSION="3.11"
NODE_VERSION="20"
API_SERVER="https://api.samureye.com.br"
GATEWAY_SERVER="192.168.100.151"

echo ""
echo "üî• SAMUREYE HARD RESET - COLLECTOR AGENT vlxsam04"
echo "==============================================="
echo "‚ö†Ô∏è  ATEN√á√ÉO: Este script ir√°:"
echo "   ‚Ä¢ Remover COMPLETAMENTE todas as ferramentas de seguran√ßa"
echo "   ‚Ä¢ Reinstalar Python, Node.js e depend√™ncias"
echo "   ‚Ä¢ Reconfigurar agente coletor do zero"
echo "   ‚Ä¢ Limpar dados de coleta anteriores"
echo "   ‚Ä¢ Reinstalar Nmap, Nuclei, Masscan e outras tools"
echo ""

# ============================================================================
# 1. CONFIRMA√á√ÉO DE HARD RESET
# ============================================================================

# Detectar se est√° sendo executado via pipe (curl | bash)
if [ -t 0 ]; then
    # Terminal interativo - pedir confirma√ß√£o
    read -p "üö® CONTINUAR COM HARD RESET? (digite 'CONFIRMO' para continuar): " confirm
    if [ "$confirm" != "CONFIRMO" ]; then
        error "Reset cancelado pelo usu√°rio"
    fi
else
    # N√£o-interativo (curl | bash) - continuar automaticamente ap√≥s delay
    warn "Modo n√£o-interativo detectado (curl | bash)"
    info "Hard reset iniciar√° automaticamente em 5 segundos..."
    sleep 5
fi

log "üóëÔ∏è Iniciando hard reset do agente coletor..."

# ============================================================================
# 2. REMO√á√ÉO COMPLETA DA INSTALA√á√ÉO ANTERIOR
# ============================================================================

log "‚èπÔ∏è Parando servi√ßos e removendo instala√ß√£o anterior..."

# Parar servi√ßo do collector
if systemctl is-active --quiet "$SERVICE_NAME" 2>/dev/null; then
    systemctl stop "$SERVICE_NAME"
    log "‚úÖ Servi√ßo $SERVICE_NAME parado"
fi

if systemctl is-enabled --quiet "$SERVICE_NAME" 2>/dev/null; then
    systemctl disable "$SERVICE_NAME"
    log "‚úÖ Servi√ßo $SERVICE_NAME desabilitado"
fi

# Remover arquivo de servi√ßo
if [ -f "/etc/systemd/system/$SERVICE_NAME.service" ]; then
    rm -f "/etc/systemd/system/$SERVICE_NAME.service"
    systemctl daemon-reload
    log "‚úÖ Arquivo de servi√ßo removido"
fi

# Remover usu√°rio collector
if id "$COLLECTOR_USER" &>/dev/null; then
    pkill -u "$COLLECTOR_USER" 2>/dev/null || true
    userdel -r "$COLLECTOR_USER" 2>/dev/null || true
    log "‚úÖ Usu√°rio $COLLECTOR_USER removido"
fi

# Remover Python e Node.js
log "üóëÔ∏è Removendo linguagens de programa√ß√£o..."
apt-get purge -y python3* nodejs npm node-* 2>/dev/null || true
rm -rf /usr/local/lib/node_modules /usr/local/bin/node /usr/local/bin/npm
rm -rf ~/.npm ~/.node-gyp /root/.npm /root/.node-gyp

# Remover ferramentas de seguran√ßa
log "üóëÔ∏è Removendo ferramentas de seguran√ßa..."
tools_to_remove=("nmap" "masscan" "gobuster" "nuclei")
for tool in "${tools_to_remove[@]}"; do
    which "$tool" >/dev/null 2>&1 && rm -f "$(which "$tool")" && log "‚úÖ $tool removido"
done

# Remover diret√≥rios do collector
directories_to_remove=(
    "$COLLECTOR_DIR"
    "$CONFIG_DIR"
    "/var/log/samureye-collector"
    "/tmp/samureye-collector"
    "/opt/nuclei-templates"
    "/opt/nmap-scripts"
    "/usr/local/share/nmap"
)

for dir in "${directories_to_remove[@]}"; do
    if [ -d "$dir" ]; then
        rm -rf "$dir"
        log "‚úÖ Removido: $dir"
    fi
done

# Remover cron jobs
crontab -l 2>/dev/null | grep -v "samureye" | crontab - 2>/dev/null || true

log "‚úÖ Remo√ß√£o completa finalizada"

# ============================================================================
# 3. ATUALIZA√á√ÉO DO SISTEMA
# ============================================================================

log "üîÑ Atualizando sistema..."
apt-get update && apt-get upgrade -y

# Configurar timezone
timedatectl set-timezone America/Sao_Paulo

# ============================================================================
# 4. INSTALA√á√ÉO DE DEPEND√äNCIAS B√ÅSICAS
# ============================================================================

log "üì¶ Instalando depend√™ncias b√°sicas..."
apt-get install -y \
    curl \
    wget \
    git \
    unzip \
    build-essential \
    cmake \
    libssl-dev \
    libffi-dev \
    zlib1g-dev \
    libbz2-dev \
    libreadline-dev \
    libsqlite3-dev \
    libncurses5-dev \
    libncursesw5-dev \
    xz-utils \
    tk-dev \
    libxml2-dev \
    libxmlsec1-dev \
    libffi-dev \
    liblzma-dev \
    ca-certificates \
    gnupg \
    lsb-release \
    software-properties-common \
    apt-transport-https \
    netcat-openbsd \
    nmap \
    jq \
    htop \
    nano \
    systemd \
    cron \
    libpcap-dev

# Instalar masscan com fallback para compila√ß√£o do c√≥digo fonte
log "üîß Instalando masscan..."
if ! apt-get install -y masscan 2>/dev/null; then
    warn "‚ö†Ô∏è Masscan via apt falhou (403 Forbidden), compilando do source..."
    cd /tmp
    
    if [ -d "masscan" ]; then
        rm -rf masscan
    fi
    
    git clone https://github.com/robertdavidgraham/masscan
    cd masscan
    make -j$(nproc) 2>/dev/null || make
    make install
    cd /
    rm -rf /tmp/masscan
    log "‚úÖ Masscan compilado e instalado do c√≥digo fonte"
else
    log "‚úÖ Masscan instalado via apt"
fi

# ============================================================================
# 5. INSTALA√á√ÉO PYTHON 3.11
# ============================================================================

log "üêç Instalando Python $PYTHON_VERSION..."

# Adicionar reposit√≥rio deadsnakes para Python 3.11
add-apt-repository -y ppa:deadsnakes/ppa
apt-get update

# Instalar Python 3.11
apt-get install -y \
    python$PYTHON_VERSION \
    python$PYTHON_VERSION-dev \
    python$PYTHON_VERSION-venv \
    python$PYTHON_VERSION-distutils

# Configurar Python padr√£o
update-alternatives --install /usr/bin/python3 python3 /usr/bin/python$PYTHON_VERSION 1
update-alternatives --install /usr/bin/python python /usr/bin/python$PYTHON_VERSION 1

# Verificar instala√ß√£o
if python$PYTHON_VERSION --version >/dev/null 2>&1; then
    python_version=$(python$PYTHON_VERSION --version 2>&1 | cut -d' ' -f2)
    log "‚úÖ Python $python_version instalado"
else
    error "‚ùå Falha na instala√ß√£o do Python $PYTHON_VERSION"
fi

# Verificar se o symlink funciona
if python --version >/dev/null 2>&1; then
    python_default=$(python --version 2>&1 | cut -d' ' -f2)
    log "‚úÖ Python padr√£o: $python_default"
else
    warn "‚ö†Ô∏è Symlink do Python pode precisar ser reconfigurado"
fi

# ============================================================================
# 6. INSTALA√á√ÉO NODE.JS
# ============================================================================

log "üì¶ Instalando Node.js $NODE_VERSION..."

# Instalar NodeSource repository
curl -fsSL https://deb.nodesource.com/setup_${NODE_VERSION}.x | bash -

# Instalar Node.js
apt-get install -y nodejs

# Verificar instala√ß√£o
node_version=$(node --version 2>&1)
if [[ "$node_version" == v${NODE_VERSION}* ]]; then
    log "‚úÖ Node.js $node_version instalado"
else
    error "‚ùå Falha na instala√ß√£o do Node.js"
fi

# ============================================================================
# 7. CRIA√á√ÉO DE USU√ÅRIO E ESTRUTURA DE DIRET√ìRIOS
# ============================================================================

log "üë§ Criando usu√°rio e estrutura de diret√≥rios..."

# Criar usu√°rio samureye-collector com grupos corretos
if ! id "$COLLECTOR_USER" &>/dev/null; then
    useradd -r -s /bin/false -d "$COLLECTOR_DIR" "$COLLECTOR_USER"
    log "‚úÖ Usu√°rio $COLLECTOR_USER criado"
else
    log "‚ÑπÔ∏è  Usu√°rio $COLLECTOR_USER j√° existe"
fi

# Adicionar usu√°rio aos grupos necess√°rios
usermod -a -G adm,systemd-journal "$COLLECTOR_USER" 2>/dev/null || true

# Criar estrutura de diret√≥rios
mkdir -p "$COLLECTOR_DIR"/{agent,certs,tools,logs,temp,uploads,scripts,config,backups}
mkdir -p "$COLLECTOR_DIR"/logs/{system,tenant-{1..10}}
mkdir -p "$COLLECTOR_DIR"/temp/{tenant-{1..10}}
mkdir -p "$COLLECTOR_DIR"/uploads/{tenant-{1..10}}
mkdir -p "$CONFIG_DIR"
mkdir -p /var/log/samureye-collector

# Estrutura de ferramentas
mkdir -p "$TOOLS_DIR"/{nmap,nuclei,masscan,gobuster,custom}

# Definir permiss√µes corretas (root:collector para config)
chown -R "$COLLECTOR_USER:$COLLECTOR_USER" "$COLLECTOR_DIR"
chown -R root:"$COLLECTOR_USER" "$CONFIG_DIR"

# CORRE√á√ÉO INTEGRADA: Permiss√µes de log para heartbeat.py
log "üîß Aplicando corre√ß√£o integrada de permiss√µes de log..."
chown -R "$COLLECTOR_USER:$COLLECTOR_USER" /var/log/samureye-collector
chmod 755 /var/log/samureye-collector

# Criar arquivo de log inicial com permiss√µes corretas
touch /var/log/samureye-collector/heartbeat.log
chown "$COLLECTOR_USER:$COLLECTOR_USER" /var/log/samureye-collector/heartbeat.log
chmod 644 /var/log/samureye-collector/heartbeat.log

chmod 750 "$COLLECTOR_DIR" "$CONFIG_DIR"
chmod 700 "$CERTS_DIR"

# Teste de permiss√µes cr√≠tico (config + log)
log "üß™ Testando permiss√µes cr√≠ticas..."
if ! sudo -u "$COLLECTOR_USER" test -r "$CONFIG_DIR" 2>/dev/null; then
    warn "‚ö†Ô∏è  Ajustando permiss√µes de emerg√™ncia para $CONFIG_DIR"
    chown -R "$COLLECTOR_USER:$COLLECTOR_USER" "$CONFIG_DIR"
    chmod 755 "$CONFIG_DIR"
fi

if ! sudo -u "$COLLECTOR_USER" touch "/var/log/samureye-collector/test_write" 2>/dev/null; then
    warn "‚ö†Ô∏è  Ajustando permiss√µes de emerg√™ncia para logs"
    chmod 777 /var/log/samureye-collector
    chmod 666 /var/log/samureye-collector/heartbeat.log
else
    rm -f "/var/log/samureye-collector/test_write"
    log "‚úÖ Permiss√µes de log: OK"
fi

log "‚úÖ Estrutura de diret√≥rios criada"

# ============================================================================
# 8. INSTALA√á√ÉO DE FERRAMENTAS DE SEGURAN√áA
# ============================================================================

log "üõ°Ô∏è Instalando ferramentas de seguran√ßa..."

# Nmap - INSTALA√á√ÉO OBRIGAT√ìRIA
log "üì° Configurando Nmap..."
if ! command -v nmap >/dev/null 2>&1; then
    log "üîÑ Instalando Nmap (OBRIGAT√ìRIO para collector)..."
    
    if apt-get update >/dev/null 2>&1 && apt-get install -y nmap >/dev/null 2>&1; then
        log "‚úÖ Nmap instalado via apt"
    else
        warn "‚ùå Falha instala√ß√£o nmap - collector funcionar√° com limita√ß√µes"
    fi
fi

if command -v nmap >/dev/null 2>&1; then
    mkdir -p "$TOOLS_DIR/nmap/scripts"
    cp /usr/share/nmap/scripts/* "$TOOLS_DIR/nmap/scripts/" 2>/dev/null || true
    chown -R "$COLLECTOR_USER:$COLLECTOR_USER" "$TOOLS_DIR/nmap"
    log "‚úÖ Nmap configurado: $(nmap --version 2>/dev/null | head -1 || echo 'vers√£o indispon√≠vel')"
else
    # Verificar se nmap foi instalado mas n√£o est√° no PATH
    if dpkg -l | grep -q nmap; then
        warn "‚ö†Ô∏è Nmap instalado mas n√£o no PATH - corrigindo..."
        NMAP_PATH=$(find /usr -name "nmap" -type f 2>/dev/null | head -1)
        if [ -n "$NMAP_PATH" ]; then
            ln -sf "$NMAP_PATH" /usr/local/bin/nmap
            log "‚úÖ Nmap linkado para PATH: $NMAP_PATH"
        else
            warn "‚ùå CR√çTICO: Nmap instalado mas bin√°rio n√£o encontrado"
        fi
    else
        warn "‚ùå CR√çTICO: Nmap n√£o dispon√≠vel - collector pode falhar"
    fi
fi

# Masscan (j√° instalado via apt ou compilado)
if command -v masscan >/dev/null 2>&1; then
    log "‚úÖ Masscan configurado"
    masscan_version=$(masscan --version 2>&1 | head -1)
    log "   Vers√£o: $masscan_version"
else
    warn "‚ùå Masscan n√£o encontrado ap√≥s instala√ß√£o"
fi

# Nuclei
log "üîç Instalando Nuclei..."
cd /tmp

# Limpar qualquer download anterior
rm -f nuclei*.zip nuclei 2>/dev/null

# Tentar instalar via apt primeiro
if apt-get install -y nuclei 2>/dev/null; then
    log "‚úÖ Nuclei instalado via apt"
else
    warn "‚ö†Ô∏è Nuclei via apt falhou, instalando via GitHub..."
    
    # Fallback: Instalar via GitHub releases
    NUCLEI_LATEST_URL=$(curl -s https://api.github.com/repos/projectdiscovery/nuclei/releases/latest | grep "browser_download_url.*nuclei.*linux_amd64\.zip" | head -1 | cut -d '"' -f 4)
    
    if [ -n "$NUCLEI_LATEST_URL" ]; then
        wget -q "$NUCLEI_LATEST_URL" -O nuclei_linux_amd64.zip
        if [ -f "nuclei_linux_amd64.zip" ]; then
            unzip -o -q nuclei_linux_amd64.zip  # -o para sobrescrever sem perguntar
            if [ -f "nuclei" ]; then
                mv nuclei /usr/local/bin/
                chmod +x /usr/local/bin/nuclei
                log "‚úÖ Nuclei instalado via GitHub"
            else
                warn "‚ùå Falha ao extrair Nuclei"
            fi
        else
            warn "‚ùå Falha ao baixar Nuclei"
        fi
    else
        warn "‚ùå N√£o foi poss√≠vel obter URL do Nuclei"
    fi
fi

# Verificar se Nuclei est√° dispon√≠vel
if command -v nuclei >/dev/null 2>&1; then
    nuclei_version=$(nuclei -version 2>&1 | head -1 | cut -d' ' -f2 || echo "unknown")
    log "‚úÖ Nuclei configurado (v$nuclei_version)"
    
    # Criar diret√≥rio para templates
    mkdir -p "$TOOLS_DIR/nuclei"
    chown -R "$COLLECTOR_USER:$COLLECTOR_USER" "$TOOLS_DIR/nuclei"
    
    # Baixar templates em background (n√£o bloquear instala√ß√£o)
    log "üìã Atualizando templates Nuclei em background..."
    (
        sleep 5  # Aguardar 5 segundos
        sudo -u "$COLLECTOR_USER" timeout 300 nuclei -update-templates -silent >/dev/null 2>&1 || true
        log "‚úÖ Templates Nuclei atualizados"
    ) &
    
else
    warn "‚ùå Nuclei n√£o est√° dispon√≠vel ap√≥s instala√ß√£o"
fi

# Gobuster
log "üîç Instalando Gobuster..."

# Tentar instalar via apt primeiro
if apt-get install -y gobuster 2>/dev/null; then
    log "‚úÖ Gobuster instalado via apt"
else
    warn "‚ö†Ô∏è Gobuster via apt falhou, instalando via GitHub..."
    
    # Fallback: Instalar via GitHub releases
    GOBUSTER_LATEST_URL=$(curl -s https://api.github.com/repos/OJ/gobuster/releases/latest | grep "browser_download_url.*gobuster.*Linux_x86_64\.tar\.gz" | head -1 | cut -d '"' -f 4)
    
    if [ -n "$GOBUSTER_LATEST_URL" ]; then
        wget -q "$GOBUSTER_LATEST_URL" -O gobuster_Linux_x86_64.tar.gz
        if [ -f "gobuster_Linux_x86_64.tar.gz" ]; then
            tar -xzf gobuster_Linux_x86_64.tar.gz --overwrite  # Sobrescrever sem perguntar
            if [ -f "gobuster" ]; then
                mv gobuster /usr/local/bin/
                chmod +x /usr/local/bin/gobuster
                log "‚úÖ Gobuster instalado via GitHub"
            else
                warn "‚ùå Falha ao extrair Gobuster"
            fi
        else
            warn "‚ùå Falha ao baixar Gobuster"
        fi
    else
        warn "‚ùå N√£o foi poss√≠vel obter URL do Gobuster"
    fi
fi

if command -v gobuster >/dev/null 2>&1; then
    gobuster_version=$(gobuster version 2>&1 | grep "Version:" | cut -d' ' -f2 || echo "unknown")
    log "‚úÖ Gobuster configurado (v$gobuster_version)"
else
    # Verificar se gobuster foi instalado mas n√£o est√° no PATH
    if dpkg -l | grep -q gobuster; then
        warn "‚ö†Ô∏è Gobuster instalado mas n√£o no PATH - corrigindo..."
        GOBUSTER_PATH=$(find /usr -name "gobuster" -type f 2>/dev/null | head -1)
        if [ -n "$GOBUSTER_PATH" ]; then
            ln -sf "$GOBUSTER_PATH" /usr/local/bin/gobuster
            log "‚úÖ Gobuster linkado para PATH: $GOBUSTER_PATH"
            gobuster_version=$(gobuster version 2>&1 | grep "Version:" | cut -d' ' -f2 || echo "unknown")
            log "   Vers√£o: v$gobuster_version"
        else
            warn "‚ùå Gobuster instalado mas bin√°rio n√£o encontrado"
        fi
    else
        warn "‚ùå Gobuster n√£o instalado via apt"
    fi
fi

# Cleanup arquivos tempor√°rios
cd /tmp
rm -f nuclei*.zip gobuster*.tar.gz nuclei gobuster LICENSE* README* 2>/dev/null || true
log "üßπ Arquivos tempor√°rios removidos"

# ============================================================================
# 9. INSTALA√á√ÉO DO AGENTE COLETOR
# ============================================================================

log "ü§ñ Instalando agente coletor..."

# Criar agente Python simples
cat > "$COLLECTOR_DIR/agent/collector.py" << 'EOF'
#!/usr/bin/env python3
"""
SamurEye Collector Agent - On-Premise
Agente coletor de dados para ambiente on-premise
"""

import os
import sys
import json
import time
import requests
import subprocess
import psutil
from datetime import datetime
import logging

# Configura√ß√µes
API_BASE = os.getenv('SAMUREYE_API_URL', 'https://api.samureye.com.br')
COLLECTOR_ID = os.getenv('COLLECTOR_ID', 'vlxsam04-collector')
ENROLLMENT_TOKEN = os.getenv('ENROLLMENT_TOKEN', '')
HEARTBEAT_INTERVAL = int(os.getenv('HEARTBEAT_INTERVAL', '30'))

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/var/log/samureye-collector/collector.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class SamurEyeCollector:
    def __init__(self):
        self.collector_id = COLLECTOR_ID
        self.api_base = API_BASE
        self.token = ENROLLMENT_TOKEN
        self.session = requests.Session()
        
    def get_system_telemetry(self):
        """Coleta telemetria do sistema"""
        try:
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            network = psutil.net_io_counters()
            
            return {
                'timestamp': datetime.utcnow().isoformat(),
                'cpu_percent': cpu_percent,
                'memory_total': memory.total,
                'memory_used': memory.used,
                'memory_percent': memory.percent,
                'disk_total': disk.total,
                'disk_used': disk.used,
                'disk_percent': (disk.used / disk.total) * 100,
                'network_io': {
                    'bytes_sent': network.bytes_sent,
                    'bytes_recv': network.bytes_recv,
                    'packets_sent': network.packets_sent,
                    'packets_recv': network.packets_recv
                },
                'processes': len(psutil.pids())
            }
        except Exception as e:
            logger.error(f"Erro ao coletar telemetria: {e}")
            return {}
    
    def send_heartbeat(self):
        """Envia heartbeat para o servidor"""
        try:
            telemetry = self.get_system_telemetry()
            
            payload = {
                'collector_id': self.collector_id,
                'status': 'online',
                'telemetry': telemetry,
                'timestamp': datetime.utcnow().isoformat()
            }
            
            if self.token:
                payload['token'] = self.token
            
            response = self.session.post(
                f'{self.api_base}/collector-api/heartbeat',
                json=payload,
                timeout=10,
                verify=False  # On-premise SSL
            )
            
            if response.status_code == 200:
                logger.info(f"Heartbeat enviado com sucesso")
                return True
            else:
                logger.warning(f"Falha no heartbeat: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"Erro ao enviar heartbeat: {e}")
            return False
    
    def run_scan(self, scan_config):
        """Executa scan baseado na configura√ß√£o"""
        try:
            scan_type = scan_config.get('type', 'nmap')
            target = scan_config.get('target', '127.0.0.1')
            
            if scan_type == 'nmap':
                return self.run_nmap_scan(target, scan_config)
            elif scan_type == 'nuclei':
                return self.run_nuclei_scan(target, scan_config)
            else:
                logger.warning(f"Tipo de scan n√£o suportado: {scan_type}")
                return None
                
        except Exception as e:
            logger.error(f"Erro ao executar scan: {e}")
            return None
    
    def run_nmap_scan(self, target, config):
        """Executa scan Nmap"""
        try:
            cmd = ['nmap', '-sS', '-O', '--version-all', target]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300
            )
            
            return {
                'type': 'nmap',
                'target': target,
                'output': result.stdout,
                'error': result.stderr,
                'return_code': result.returncode,
                'timestamp': datetime.utcnow().isoformat()
            }
            
        except subprocess.TimeoutExpired:
            logger.error("Timeout no scan Nmap")
            return None
        except Exception as e:
            logger.error(f"Erro no scan Nmap: {e}")
            return None
    
    def run_nuclei_scan(self, target, config):
        """Executa scan Nuclei"""
        try:
            cmd = ['nuclei', '-u', target, '-json']
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=600
            )
            
            return {
                'type': 'nuclei',
                'target': target,
                'output': result.stdout,
                'error': result.stderr,
                'return_code': result.returncode,
                'timestamp': datetime.utcnow().isoformat()
            }
            
        except subprocess.TimeoutExpired:
            logger.error("Timeout no scan Nuclei")
            return None
        except Exception as e:
            logger.error(f"Erro no scan Nuclei: {e}")
            return None
    
    def run(self):
        """Loop principal do collector"""
        logger.info(f"Iniciando SamurEye Collector: {self.collector_id}")
        
        while True:
            try:
                # Enviar heartbeat
                self.send_heartbeat()
                
                # Aguardar pr√≥ximo ciclo
                time.sleep(HEARTBEAT_INTERVAL)
                
            except KeyboardInterrupt:
                logger.info("Collector interrompido pelo usu√°rio")
                break
            except Exception as e:
                logger.error(f"Erro no loop principal: {e}")
                time.sleep(5)

if __name__ == "__main__":
    collector = SamurEyeCollector()
    collector.run()
EOF

# Tornar execut√°vel
chmod +x "$COLLECTOR_DIR/agent/collector.py"
chown "$COLLECTOR_USER:$COLLECTOR_USER" "$COLLECTOR_DIR/agent/collector.py"

# Instalar depend√™ncias Python via apt (Ubuntu 24.04)
log "üì¶ Instalando depend√™ncias Python..."
apt-get install -y python3-psutil python3-requests python3-venv

if python3 -c "import psutil, requests" 2>/dev/null; then
    log "‚úÖ Depend√™ncias Python instaladas"
else
    warn "‚ö†Ô∏è Algumas depend√™ncias Python podem estar ausentes"
fi

# ============================================================================
# 10. CONFIGURA√á√ÉO DO SERVI√áO SYSTEMD
# ============================================================================

log "üîß Configurando servi√ßo systemd..."

cat > "/etc/systemd/system/$SERVICE_NAME.service" << EOF
[Unit]
Description=SamurEye Collector Agent
After=network.target
Wants=network.target

[Service]
Type=simple
User=$COLLECTOR_USER
Group=$COLLECTOR_USER
WorkingDirectory=$COLLECTOR_DIR/agent
Environment=SAMUREYE_API_URL=$API_SERVER
Environment=COLLECTOR_ID=vlxsam04-collector-$(date +%s)
Environment=HEARTBEAT_INTERVAL=30
ExecStart=/usr/bin/python3 $COLLECTOR_DIR/agent/collector.py
Restart=always
RestartSec=10
StandardOutput=append:/var/log/samureye-collector/collector.log
StandardError=append:/var/log/samureye-collector/error.log

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=$COLLECTOR_DIR /var/log/samureye-collector /tmp

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload

log "‚úÖ Servi√ßo systemd configurado"

# ============================================================================
# 11. CONFIGURA√á√ÉO DE CRON JOBS
# ============================================================================

log "‚è∞ Configurando cron jobs..."

# Criar script de limpeza
cat > "$COLLECTOR_DIR/scripts/cleanup.sh" << 'EOF'
#!/bin/bash
# Script de limpeza autom√°tica do collector

COLLECTOR_DIR="/opt/samureye/collector"
LOG_DIR="/var/log/samureye-collector"

# Limpar logs antigos (mais de 7 dias)
find $LOG_DIR -name "*.log" -mtime +7 -delete 2>/dev/null || true

# Limpar arquivos tempor√°rios (mais de 1 dia)
find $COLLECTOR_DIR/temp -type f -mtime +1 -delete 2>/dev/null || true

# Limpar uploads antigos (mais de 3 dias)
find $COLLECTOR_DIR/uploads -type f -mtime +3 -delete 2>/dev/null || true

# Log da limpeza
echo "$(date): Limpeza autom√°tica executada" >> $LOG_DIR/cleanup.log
EOF

chmod +x "$COLLECTOR_DIR/scripts/cleanup.sh"
chown "$COLLECTOR_USER:$COLLECTOR_USER" "$COLLECTOR_DIR/scripts/cleanup.sh"

# Adicionar cron job
(crontab -l 2>/dev/null; echo "0 2 * * * $COLLECTOR_DIR/scripts/cleanup.sh") | crontab -

log "‚úÖ Cron jobs configurados"

# ============================================================================
# 12. CONFIGURA√á√ÉO DE FIREWALL
# ============================================================================

log "üîí Configurando firewall..."

# Instalar UFW se n√£o estiver instalado
apt-get install -y ufw

# Reset UFW
ufw --force reset

# Pol√≠tica padr√£o
ufw default deny incoming
ufw default allow outgoing

# Permitir SSH
ufw allow 22/tcp

# Permitir acesso para rede SamurEye
ufw allow from 192.168.100.0/24

# Permitir HTTPS para API (sa√≠da)
ufw allow out 443/tcp

# Ativar firewall
ufw --force enable

log "‚úÖ Firewall configurado"

# ============================================================================
# 13. INICIALIZA√á√ÉO DO SERVI√áO
# ============================================================================

log "üöÄ Iniciando servi√ßo collector..."

# Habilitar e iniciar servi√ßo
systemctl enable "$SERVICE_NAME"
systemctl start "$SERVICE_NAME"

# Aguardar inicializa√ß√£o
sleep 10

# Verificar status
if systemctl is-active --quiet "$SERVICE_NAME"; then
    log "‚úÖ Collector iniciado com sucesso"
else
    warn "‚ö†Ô∏è Collector pode ter problemas - verificar logs"
fi

# ============================================================================
# 14. TESTES DE VALIDA√á√ÉO
# ============================================================================

log "üß™ Executando testes de valida√ß√£o..."

# Teste 1: Servi√ßo ativo
if systemctl is-active --quiet "$SERVICE_NAME"; then
    log "‚úÖ Servi√ßo: Ativo"
else
    warn "‚ö†Ô∏è Servi√ßo: Inativo"
fi

# Teste 2: Python funcionando
if python3 -c "import psutil, requests" 2>/dev/null; then
    log "‚úÖ Python: Depend√™ncias OK"
else
    warn "‚ö†Ô∏è Python: Problemas com depend√™ncias"
fi

# Teste 3: Ferramentas de seguran√ßa
tools_status=""
for tool in nmap nuclei masscan gobuster; do
    if command -v "$tool" >/dev/null 2>&1; then
        tools_status="$tools_status $tool:‚úÖ"
    else
        tools_status="$tools_status $tool:‚ùå"
    fi
done
log "üõ°Ô∏è Ferramentas:$tools_status"

# Teste 4: Conectividade com API
if curl -s -k --connect-timeout 5 "$API_SERVER/api/health" >/dev/null 2>&1; then
    log "‚úÖ API: Conectividade OK"
else
    warn "‚ö†Ô∏è API: Sem conectividade"
fi

# Teste 5: Logs sendo gerados
if [ -f "/var/log/samureye-collector/collector.log" ]; then
    log "‚úÖ Logs: Sendo gerados"
else
    warn "‚ö†Ô∏è Logs: N√£o encontrados"
fi

# ============================================================================
# 14.5. CORRE√á√ÉO AUTOM√ÅTICA DE HEARTBEAT
# ============================================================================

log "üíì Configurando corre√ß√µes de heartbeat e conectividade..."

# Verificar e corrigir configura√ß√£o para heartbeat
CONFIG_FILE="/etc/samureye-collector/.env"

if [ -f "$CONFIG_FILE" ]; then
    # Garantir que API_BASE est√° correto
    if ! grep -q "API_BASE.*https://api.samureye.com.br" "$CONFIG_FILE"; then
        if grep -q "^API_BASE=" "$CONFIG_FILE"; then
            sed -i 's|^API_BASE=.*|API_BASE=https://api.samureye.com.br|' "$CONFIG_FILE"
        else
            echo "API_BASE=https://api.samureye.com.br" >> "$CONFIG_FILE"
        fi
        log "‚úÖ API_BASE corrigido para https://api.samureye.com.br"
    fi
    
    # Garantir intervalo de heartbeat adequado (30 segundos)
    if ! grep -q "^HEARTBEAT_INTERVAL=" "$CONFIG_FILE"; then
        echo "HEARTBEAT_INTERVAL=30" >> "$CONFIG_FILE"
        log "‚úÖ HEARTBEAT_INTERVAL configurado (30 segundos)"
    else
        # Verificar se n√£o est√° muito baixo (m√≠nimo 15 segundos)
        CURRENT_INTERVAL=$(grep "^HEARTBEAT_INTERVAL=" "$CONFIG_FILE" | cut -d= -f2)
        if [ "$CURRENT_INTERVAL" -lt 15 ] 2>/dev/null; then
            sed -i 's/^HEARTBEAT_INTERVAL=.*/HEARTBEAT_INTERVAL=30/' "$CONFIG_FILE"
            log "‚úÖ HEARTBEAT_INTERVAL ajustado para 30 segundos (estava muito baixo)"
        fi
    fi
    
    # Adicionar configura√ß√£o de retry para heartbeat
    if ! grep -q "^HEARTBEAT_RETRY_COUNT=" "$CONFIG_FILE"; then
        echo "HEARTBEAT_RETRY_COUNT=3" >> "$CONFIG_FILE"
        log "‚úÖ HEARTBEAT_RETRY_COUNT configurado (3 tentativas)"
    fi
    
    # Adicionar timeout para requests HTTP
    if ! grep -q "^HTTP_TIMEOUT=" "$CONFIG_FILE"; then
        echo "HTTP_TIMEOUT=30" >> "$CONFIG_FILE"
        log "‚úÖ HTTP_TIMEOUT configurado (30 segundos)"
    fi
    
    # Configura√ß√£o de log level para debug inicial
    if ! grep -q "^LOG_LEVEL=" "$CONFIG_FILE"; then
        echo "LOG_LEVEL=INFO" >> "$CONFIG_FILE"
        log "‚úÖ LOG_LEVEL configurado (INFO)"
    fi
    
else
    warn "‚ö†Ô∏è Arquivo de configura√ß√£o $CONFIG_FILE n√£o encontrado"
fi

# Criar script de teste de conectividade
cat > "$COLLECTOR_DIR/test-connectivity.sh" << 'EOF'
#!/bin/bash

# Script para testar conectividade do collector
CERTS_DIR="/opt/samureye-collector/certs"
API_BASE="https://api.samureye.com.br"

echo "üîß Testando conectividade do collector..."

# Teste DNS
if nslookup api.samureye.com.br >/dev/null 2>&1; then
    echo "‚úÖ DNS: api.samureye.com.br"
else
    echo "‚ùå DNS: Falha na resolu√ß√£o"
    exit 1
fi

# Teste porta
if timeout 5 bash -c "</dev/tcp/api.samureye.com.br/443" >/dev/null 2>&1; then
    echo "‚úÖ Conectividade: Porta 443 acess√≠vel"
else
    echo "‚ùå Conectividade: Porta 443 bloqueada"
    exit 1
fi

# Teste certificados
if [ -f "$CERTS_DIR/collector.crt" ] && [ -f "$CERTS_DIR/collector.key" ]; then
    echo "‚úÖ Certificados: Encontrados"
    
    # Teste heartbeat
    RESPONSE=$(curl -k \
        --cert "$CERTS_DIR/collector.crt" \
        --key "$CERTS_DIR/collector.key" \
        --connect-timeout 10 \
        --max-time 30 \
        -X POST \
        -H "Content-Type: application/json" \
        -d "{
            \"collector_id\": \"$(hostname)\",
            \"status\": \"online\",
            \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)\",
            \"telemetry\": {
                \"cpu_percent\": 15.0,
                \"memory_percent\": 45.0,
                \"disk_percent\": 30.0,
                \"processes\": 100
            },
            \"capabilities\": [\"nmap\", \"nuclei\", \"masscan\"],
            \"version\": \"1.0.0\"
        }" \
        "$API_BASE/collector-api/heartbeat" 2>/dev/null || echo "ERROR")
    
    if [[ "$RESPONSE" == *"Heartbeat received"* ]]; then
        echo "‚úÖ Heartbeat: Teste manual bem-sucedido"
        echo "   Resposta: $RESPONSE"
    else
        echo "‚ùå Heartbeat: Falha no teste manual"
        echo "   Resposta: $RESPONSE"
        exit 1
    fi
else
    echo "‚ùå Certificados: N√£o encontrados em $CERTS_DIR"
    exit 1
fi

echo ""
echo "üéâ Todos os testes de conectividade passaram!"
EOF

chmod +x "$COLLECTOR_DIR/test-connectivity.sh"
chown "$COLLECTOR_USER:$COLLECTOR_USER" "$COLLECTOR_DIR/test-connectivity.sh"

log "‚úÖ Script de teste de conectividade criado: $COLLECTOR_DIR/test-connectivity.sh"

# Testar conectividade imediatamente ap√≥s instala√ß√£o
if [ -f "$COLLECTOR_DIR/certs/collector.crt" ] && [ -f "$COLLECTOR_DIR/certs/collector.key" ]; then
    log "üß™ Executando teste de conectividade imediato..."
    if sudo -u "$COLLECTOR_USER" "$COLLECTOR_DIR/test-connectivity.sh"; then
        log "‚úÖ Teste de conectividade inicial: SUCESSO"
    else
        warn "‚ö†Ô∏è Teste de conectividade inicial: FALHOU - verificar configura√ß√£o"
    fi
else
    warn "‚ö†Ô∏è Certificados n√£o encontrados - teste de conectividade pulado"
fi

# ============================================================================
# 15. SCRIPT DE REGISTRO NO SERVIDOR
# ============================================================================

log "üìù Criando script de registro..."

# Remover script register.sh antigo - ser√° substitu√≠do pelo heartbeat integrado
log "üìù Sistema de registro integrado ao heartbeat implementado"

# ============================================================================
# CORRE√á√ÉO INTEGRADA DE DUPLICA√á√ÉO DE COLETORES
# ============================================================================

log "üîß Implementando corre√ß√£o de duplica√ß√£o de coletores..."

# Criar configura√ß√£o robusta para evitar duplica√ß√£o - EXPANDIR VARI√ÅVEIS
cat > "$CONFIG_FILE" << CONFIG_EOF
# Configura√ß√£o do Collector SamurEye - Anti-duplica√ß√£o
COLLECTOR_ID=$HOSTNAME
COLLECTOR_NAME=${COLLECTOR_NAME}
HOSTNAME=$HOSTNAME
IP_ADDRESS=${IP_ADDRESS}
SAMUREYE_API_URL=${API_SERVER}
HEARTBEAT_INTERVAL=30
RETRY_ATTEMPTS=3
RETRY_DELAY=5
LOG_LEVEL=INFO

# Tokens de autentica√ß√£o (preenchidos durante registro)
COLLECTOR_TOKEN=
ENROLLMENT_TOKEN=

# Status do collector
STATUS=offline
CONFIG_EOF

# Aplicar permiss√µes corretas ao diret√≥rio e arquivo .env
chown root:"$COLLECTOR_USER" "$CONFIG_DIR"
chown root:"$COLLECTOR_USER" "$CONFIG_FILE"
chmod 750 "$CONFIG_DIR"
chmod 640 "$CONFIG_FILE"

# Teste de permiss√µes cr√≠tico
log "üîç Testando permiss√µes de leitura do arquivo de configura√ß√£o..."
if sudo -u "$COLLECTOR_USER" cat "$CONFIG_FILE" >/dev/null 2>&1; then
    log "‚úÖ Permiss√µes de leitura: OK"
else
    warn "‚ö†Ô∏è  Permiss√µes de leitura: FALHOU - aplicando corre√ß√£o de emerg√™ncia"
    # Fallback para garantir funcionalidade
    chown "$COLLECTOR_USER":"$COLLECTOR_USER" "$CONFIG_FILE"
    chmod 644 "$CONFIG_FILE"
    
    # Verificar novamente
    if sudo -u "$COLLECTOR_USER" cat "$CONFIG_FILE" >/dev/null 2>&1; then
        log "‚úÖ Permiss√µes corrigidas com fallback"
    else
        error "‚ùå FALHA CR√çTICA: Usu√°rio n√£o consegue ler arquivo de configura√ß√£o"
    fi
fi

# Criar script de heartbeat robusto integrado
cat > "$COLLECTOR_DIR/heartbeat.py" << 'HEARTBEAT_EOF'
#!/usr/bin/env python3
"""
Script de heartbeat robusto para SamurEye Collector
Evita duplica√ß√£o e gerencia status automaticamente
"""

import os
import sys
import json
import time
import socket
import requests
import logging
import psutil
from pathlib import Path
import urllib3

# Suprimir warning SSL para ambiente on-premise
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/var/log/samureye-collector/heartbeat.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class CollectorHeartbeat:
    def __init__(self):
        self.load_config()
        self.session = requests.Session()
        self.session.verify = False
        
    def load_config(self):
        try:
            # Carregar arquivo .env principal
            env_file = Path("/etc/samureye-collector/.env")
            if env_file.exists():
                with open(env_file) as f:
                    for line in f:
                        if '=' in line and not line.startswith('#'):
                            key, value = line.strip().split('=', 1)
                            os.environ[key] = value
                            
            self.collector_id = os.environ.get('COLLECTOR_ID', socket.gethostname())
            self.collector_name = os.environ.get('COLLECTOR_NAME', f"{socket.gethostname()}-collector")
            self.hostname = os.environ.get('HOSTNAME', socket.gethostname())
            self.ip_address = os.environ.get('IP_ADDRESS', self.get_local_ip())
            self.api_base = os.environ.get('API_BASE_URL', 'https://api.samureye.com.br')
            self.heartbeat_interval = int(os.environ.get('HEARTBEAT_INTERVAL', '30'))
            
            # CORRE√á√ÉO: Ler COLLECTOR_TOKEN do arquivo .env (salvo pelo registro externo)
            self.collector_token = os.environ.get('COLLECTOR_TOKEN', '').strip()
            
            # Manter compatibilidade com token.conf para enrollment
            token_file = Path("/etc/samureye-collector/token.conf")
            self.enrollment_token = None
            if token_file.exists():
                with open(token_file) as f:
                    for line in f:
                        if line.startswith('ENROLLMENT_TOKEN='):
                            self.enrollment_token = line.strip().split('=', 1)[1]
                            break
            
            # Status do token
            if self.collector_token:
                logger.info(f"Configura√ß√£o carregada - ID: {self.collector_id}, Token: {self.collector_token[:8]}...{self.collector_token[-8:]}")
            else:
                logger.info(f"Configura√ß√£o carregada - ID: {self.collector_id}, Token: N√ÉO CONFIGURADO")
            
        except Exception as e:
            logger.error(f"Erro ao carregar configura√ß√£o: {e}")
            sys.exit(1)
            
    def get_local_ip(self):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "127.0.0.1"
            
    def get_telemetry(self):
        try:
            cpu_percent = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            return {
                "cpu_percent": cpu_percent,
                "memory_percent": memory.percent,
                "disk_percent": disk.percent,
                "processes": len(psutil.pids()),
                "memory_total": memory.total,
                "disk_total": disk.total,
                "uptime": int(time.time() - psutil.boot_time())
            }
        except Exception as e:
            logger.warning(f"Erro ao coletar telemetria: {e}")
            return {"cpu_percent": 0, "memory_percent": 0, "disk_percent": 0, "processes": 0}
            
    def register_collector(self):
        try:
            url = f"{self.api_base}/api/collectors"
            data = {
                "name": self.collector_name,
                "hostname": self.hostname,
                "ipAddress": self.ip_address,
                "status": "enrolling",
                "description": f"Collector agent on-premise {self.hostname}"
            }
            
            logger.info(f"Registrando collector: {data}")
            response = self.session.post(url, json=data, timeout=30)
            
            if response.status_code == 200:
                result = response.json()
                if 'enrollmentToken' in result:
                    self.enrollment_token = result['enrollmentToken']
                    
                    with open('/etc/samureye-collector/token.conf', 'w') as f:
                        f.write(f"ENROLLMENT_TOKEN={self.enrollment_token}\n")
                    os.chmod('/etc/samureye-collector/token.conf', 0o600)
                    
                    logger.info("Collector registrado com sucesso (reutiliza existente se duplicado)")
                    return True
                    
            logger.error(f"Erro no registro: {response.status_code} - {response.text}")
            return False
            
        except Exception as e:
            logger.error(f"Erro ao registrar collector: {e}")
            return False
            
    def send_heartbeat(self):
        try:
            url = f"{self.api_base}/collector-api/heartbeat"
            telemetry = self.get_telemetry()
            
            # CORRE√á√ÉO: API espera collector_id (snake_case) n√£o collectorId (camelCase)
            data = {
                "collector_id": self.collector_id,
                "hostname": self.hostname,
                "ipAddress": self.ip_address,
                "status": "online",
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S.000Z", time.gmtime()),
                "telemetry": telemetry,
                "capabilities": ["nmap", "nuclei", "masscan", "journey_execution"],
                "version": "1.0.1"
            }
            
            # CORRE√á√ÉO CR√çTICA: N√£o usar enrollment_token para heartbeat
            # O heartbeat deve usar COLLECTOR_TOKEN do registro externo
            if not self.collector_token:
                logger.debug("COLLECTOR_TOKEN ausente - n√£o enviando heartbeat")
                return False
            
            # Usar COLLECTOR_TOKEN com Authorization Bearer
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.collector_token}",
                "X-Collector-Token": self.collector_token
            }
                
            response = self.session.post(url, json=data, headers=headers, timeout=30)
            
            if response.status_code == 200:
                result = response.json()
                logger.debug(f"Heartbeat enviado - Status: {result.get('status', 'unknown')}")
                
                if result.get('transitioned'):
                    logger.info("‚úÖ Collector transicionou de ENROLLING para ONLINE")
                    
                return True
            elif response.status_code == 401:
                logger.warning("Token inv√°lido ou expirado - collector precisa ser re-registrado")
                return False
            elif response.status_code == 404:
                logger.warning("Collector n√£o encontrado na API")
                return False
            else:
                logger.error(f"Erro no heartbeat: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            logger.error(f"Erro ao enviar heartbeat: {e}")
            return False

    def get_pending_journeys(self):
        """Busca jornadas pendentes para este collector"""
        try:
            if not self.collector_token or not self.collector_id:
                logger.error("üö® DEBUG: collector_token ou collector_id ausente!")
                logger.error(f"   collector_token: {'SET' if self.collector_token else 'MISSING'}")
                logger.error(f"   collector_id: {'SET' if self.collector_id else 'MISSING'}")
                return []

            url = f"{self.api_base}/collector-api/journeys/pending"
            params = {
                "collector_id": self.collector_id,
                "token": self.collector_token  # Usar apenas collector_token permanente
            }
            
            # üîç DEBUG DETALHADO
            logger.info("üîç DEBUG: Fazendo requisi√ß√£o para buscar jornadas pendentes...")
            logger.info(f"   URL: {url}")
            logger.info(f"   collector_id: {self.collector_id}")
            logger.info(f"   token: {self.collector_token[:8]}...{self.collector_token[-8:] if len(self.collector_token) > 16 else self.collector_token}")
            logger.info(f"   URL completa: {url}?collector_id={self.collector_id}&token={self.collector_token[:8]}...{self.collector_token[-8:]}")
            
            start_time = time.time()
            response = self.session.get(url, params=params, timeout=30)
            duration = time.time() - start_time
            
            # üîç DEBUG RESPOSTA
            logger.info(f"üîç DEBUG: Resposta recebida em {duration:.2f}s")
            logger.info(f"   Status Code: {response.status_code}")
            logger.info(f"   Headers: {dict(response.headers)}")
            logger.info(f"   Response Body: {response.text[:500]}...")
            
            if response.status_code == 200:
                try:
                    journeys = response.json()
                    logger.info(f"‚úÖ DEBUG: {len(journeys)} jornadas pendentes encontradas")
                    if journeys:
                        logger.info(f"   Primeira jornada: {journeys[0] if journeys else 'N/A'}")
                    return journeys
                except Exception as json_err:
                    logger.error(f"üö® DEBUG: Erro ao fazer parse JSON: {json_err}")
                    logger.error(f"   Response text: {response.text}")
                    return []
            elif response.status_code == 401:
                logger.error("üö® DEBUG: HTTP 401 - Token inv√°lido ou expirado")
                logger.error(f"   Response: {response.text}")
                logger.error(f"   Headers enviados: {dict(self.session.headers) if hasattr(self.session, 'headers') else 'N/A'}")
                return []
            else:
                logger.error(f"üö® DEBUG: HTTP {response.status_code} - Erro inesperado")
                logger.error(f"   Response: {response.text}")
                return []
                
        except Exception as e:
            logger.error(f"üö® DEBUG: Exception ao buscar jornadas pendentes: {e}")
            logger.error(f"   Tipo: {type(e)}")
            logger.error(f"   Args: {e.args}")
            import traceback
            logger.error(f"   Traceback: {traceback.format_exc()}")
            return []

    def execute_nmap_scan(self, target, options=None):
        """Executa scan nmap no target especificado"""
        try:
            # Verificar se nmap est√° dispon√≠vel
            nmap_path = "/usr/bin/nmap"
            if not os.path.exists(nmap_path):
                # Tentar encontrar nmap no PATH
                import shutil
                nmap_path = shutil.which("nmap")
                if not nmap_path:
                    return {"error": "Nmap n√£o encontrado no sistema"}

            # Construir comando nmap baseado nas op√ß√µes
            cmd = [nmap_path]
            
            # Op√ß√µes padr√£o
            default_options = ["-sS", "-O", "-sV", "--version-light", "-T4"]
            
            if options and isinstance(options, dict):
                # Personalizar scan baseado nas op√ß√µes
                if options.get("service_scan"):
                    cmd.extend(["-sV"])
                if options.get("os_detection"):
                    cmd.extend(["-O"])
                if options.get("script_scan"):
                    cmd.extend(["--script=default"])
                if options.get("port_range"):
                    cmd.extend(["-p", options["port_range"]])
                else:
                    cmd.extend(["-p", "1-1000"])  # Top 1000 ports por padr√£o
            else:
                cmd.extend(default_options)
                cmd.extend(["-p", "1-1000"])

            cmd.append(target)
            
            logger.info(f"Executando nmap scan: {' '.join(cmd)}")
            
            # Executar comando com timeout
            import subprocess
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                timeout=900,  # 15 minutos timeout
                cwd="/tmp"
            )
            
            return {
                "tool": "nmap",
                "target": target,
                "command": ' '.join(cmd),
                "exit_code": result.returncode,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "success": result.returncode == 0
            }
            
        except subprocess.TimeoutExpired:
            logger.error(f"Nmap scan timeout para {target}")
            return {"error": f"Nmap scan timeout para {target}"}
        except Exception as e:
            logger.error(f"Erro ao executar nmap scan: {e}")
            return {"error": str(e)}

    def execute_nuclei_scan(self, target, options=None):
        """Executa scan nuclei no target especificado"""
        try:
            # Verificar se nuclei est√° dispon√≠vel
            nuclei_path = "/usr/local/bin/nuclei"
            if not os.path.exists(nuclei_path):
                import shutil
                nuclei_path = shutil.which("nuclei")
                if not nuclei_path:
                    return {"error": "Nuclei n√£o encontrado no sistema"}

            cmd = [nuclei_path, "-u", target]
            
            # Op√ß√µes padr√£o
            cmd.extend(["-t", "/opt/nuclei-templates/", "-json", "-silent"])
            
            if options and isinstance(options, dict):
                if options.get("severity"):
                    cmd.extend(["-severity", options["severity"]])
                if options.get("tags"):
                    cmd.extend(["-tags", options["tags"]])
                if options.get("exclude_tags"):
                    cmd.extend(["-exclude-tags", options["exclude_tags"]])
            
            logger.info(f"Executando nuclei scan: {' '.join(cmd)}")
            
            import subprocess
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=1200,  # 20 minutos timeout
                cwd="/tmp"
            )
            
            # Parse JSON output
            findings = []
            if result.stdout:
                for line in result.stdout.strip().split('\\n'):
                    if line.strip():
                        try:
                            import json
                            finding = json.loads(line)
                            findings.append(finding)
                        except json.JSONDecodeError:
                            continue
            
            return {
                "tool": "nuclei",
                "target": target,
                "command": ' '.join(cmd),
                "exit_code": result.returncode,
                "findings": findings,
                "stderr": result.stderr,
                "success": result.returncode == 0
            }
            
        except subprocess.TimeoutExpired:
            logger.error(f"Nuclei scan timeout para {target}")
            return {"error": f"Nuclei scan timeout para {target}"}
        except Exception as e:
            logger.error(f"Erro ao executar nuclei scan: {e}")
            return {"error": str(e)}

    def execute_journey(self, journey_execution):
        """Executa uma jornada de seguran√ßa"""
        try:
            execution_id = journey_execution.get("id")
            journey_config = journey_execution.get("config", {})
            target = journey_config.get("target")
            scan_types = journey_config.get("scanTypes", [])
            
            if not target:
                return {"error": "Target n√£o especificado na jornada"}
            
            logger.info(f"Executando jornada {execution_id} para target {target}")
            
            results = {
                "execution_id": execution_id,
                "target": target,
                "start_time": time.strftime("%Y-%m-%dT%H:%M:%S.000Z", time.gmtime()),
                "scans": {}
            }
            
            # Executar scans baseado na configura√ß√£o
            for scan_type in scan_types:
                if scan_type == "nmap":
                    nmap_options = journey_config.get("nmapOptions")
                    results["scans"]["nmap"] = self.execute_nmap_scan(target, nmap_options)
                elif scan_type == "nuclei":
                    nuclei_options = journey_config.get("nucleiOptions")
                    results["scans"]["nuclei"] = self.execute_nuclei_scan(target, nuclei_options)
            
            results["end_time"] = time.strftime("%Y-%m-%dT%H:%M:%S.000Z", time.gmtime())
            results["success"] = True
            
            logger.info(f"Jornada {execution_id} conclu√≠da com sucesso")
            return results
            
        except Exception as e:
            logger.error(f"Erro ao executar jornada: {e}")
            return {
                "execution_id": journey_execution.get("id"),
                "error": str(e),
                "success": False
            }

    def submit_journey_results(self, execution_id, results):
        """Envia resultados da jornada para o servidor"""
        try:
            if not self.collector_token or not self.collector_id:
                logger.warning("Token ou ID do collector ausente - n√£o enviando resultados")
                return False

            url = f"{self.api_base}/collector-api/journeys/results"
            
            # Determinar status baseado nos resultados
            status = "completed" if results.get("success") else "failed"
            error_message = results.get("error") if not results.get("success") else None
            
            data = {
                "collector_id": self.collector_id,
                "token": self.collector_token,  # Usar apenas collector_token permanente
                "execution_id": execution_id,
                "status": status,
                "results": results,
                "error_message": error_message
            }
            
            response = self.session.post(url, json=data, timeout=60)
            
            if response.status_code == 200:
                logger.info(f"Resultados da jornada {execution_id} enviados com sucesso")
                return True
            else:
                logger.error(f"Erro ao enviar resultados: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            logger.error(f"Erro ao enviar resultados da jornada: {e}")
            return False

    def process_pending_journeys(self):
        """Processa jornadas pendentes"""
        try:
            pending_journeys = self.get_pending_journeys()
            
            for journey_execution in pending_journeys:
                execution_id = journey_execution.get("id")
                logger.info(f"Processando jornada {execution_id}")
                
                # Executar jornada
                results = self.execute_journey(journey_execution)
                
                # Enviar resultados
                self.submit_journey_results(execution_id, results)
                
        except Exception as e:
            logger.error(f"Erro ao processar jornadas pendentes: {e}")
            
    def run(self):
        logger.info("Iniciando heartbeat collector...")
        
        # CORRE√á√ÉO: Verificar COLLECTOR_TOKEN em vez de enrollment_token
        if not self.collector_token:
            logger.warning("COLLECTOR_TOKEN n√£o encontrado - collector precisa ser registrado")
            logger.info("Execute: curl -fsSL .../register-collector.sh | bash -s -- <tenant> <token>")
            
            # Tentar auto-registro como fallback se h√° enrollment_token
            if self.enrollment_token:
                logger.info("Tentando auto-registro com enrollment_token...")
                if not self.register_collector():
                    logger.error("Falha no auto-registro - aguardando token v√°lido")
                    # N√£o fazer return, continuar loop aguardando token
            else:
                logger.error("Nenhum token dispon√≠vel - aguardando registro manual")
                
        consecutive_failures = 0
        max_failures = 5
        
        while True:
            try:
                # Recarregar configura√ß√£o periodicamente para pegar novo token
                if consecutive_failures % 3 == 0:
                    self.load_config()
                
                # S√≥ tentar heartbeat se h√° token
                if self.collector_token:
                    # Enviar heartbeat
                    if self.send_heartbeat():
                        consecutive_failures = 0
                    else:
                        consecutive_failures += 1
                        
                        if consecutive_failures >= max_failures:
                            logger.warning("Muitas falhas consecutivas - recarregando configura√ß√£o")
                            self.load_config()
                            consecutive_failures = 0
                    
                    # Processar jornadas pendentes a cada ciclo
                    try:
                        self.process_pending_journeys()
                    except Exception as e:
                        logger.error(f"Erro no processamento de jornadas: {e}")
                else:
                    logger.debug("Aguardando COLLECTOR_TOKEN...")
                    consecutive_failures += 1
                        
                time.sleep(self.heartbeat_interval)
                
            except KeyboardInterrupt:
                logger.info("Heartbeat interrompido pelo usu√°rio")
                break
            except Exception as e:
                logger.error(f"Erro no loop de heartbeat: {e}")
                time.sleep(self.heartbeat_interval)

if __name__ == "__main__":
    heartbeat = CollectorHeartbeat()
    heartbeat.run()
HEARTBEAT_EOF

chmod +x "$COLLECTOR_DIR/heartbeat.py"
chown "$COLLECTOR_USER:$COLLECTOR_USER" "$COLLECTOR_DIR/heartbeat.py"

# Atualizar servi√ßo systemd para usar heartbeat robusto - PATHS ABSOLUTOS
cat > /etc/systemd/system/$SERVICE_NAME.service << 'SERVICE_EOF'
[Unit]
Description=SamurEye Collector Agent
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
Restart=always
RestartSec=10
User=samureye-collector
Group=samureye-collector
WorkingDirectory=/opt/samureye/collector
ExecStart=/usr/bin/python3 /opt/samureye/collector/heartbeat.py
StandardOutput=append:/var/log/samureye-collector/collector.log
StandardError=append:/var/log/samureye-collector/collector.log
Environment=PYTHONUNBUFFERED=1

[Install]
WantedBy=multi-user.target
SERVICE_EOF

# Verificar integridade do arquivo systemd
if ! systemd-analyze verify /etc/systemd/system/$SERVICE_NAME.service 2>/dev/null; then
    warn "‚ùå Arquivo systemd inv√°lido - corrigindo..."
    # Fallback com paths absolutos garantidos
    cat > /etc/systemd/system/$SERVICE_NAME.service << 'FALLBACK_EOF'
[Unit]
Description=SamurEye Collector Agent
After=network.target

[Service]
Type=simple
Restart=always
RestartSec=10
User=samureye-collector
Group=samureye-collector
WorkingDirectory=/opt/samureye/collector
ExecStart=/usr/bin/python3 /opt/samureye/collector/heartbeat.py
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
FALLBACK_EOF
fi

systemctl daemon-reload

log "‚úÖ Sistema anti-duplica√ß√£o integrado no install-hard-reset"

# SISTEMA BASE PRONTO - REGISTRO MANUAL NECESS√ÅRIO
log "‚ö†Ô∏è Sistema base instalado - registro manual necess√°rio"
log "üìã Use o script de registro separado com token do tenant"

# ============================================================================
# SCRIPTS DE DIAGN√ìSTICO INTEGRADOS NO INSTALL
# ============================================================================

log "üìã Criando scripts de diagn√≥stico e utilit√°rios integrados..."

# Script para salvar tokens corretamente (integrado)
cat > "$COLLECTOR_DIR/scripts/save-token.sh" << 'SAVE_TOKEN_EOF'
#!/bin/bash

# Script para salvar token no arquivo de configura√ß√£o
# Uso: save-token.sh <collector_token> [enrollment_token]

CONFIG_FILE="/etc/samureye-collector/.env"

if [ $# -lt 1 ]; then
    echo "Erro: Token do collector √© obrigat√≥rio"
    echo "Uso: $0 <collector_token> [enrollment_token]"
    exit 1
fi

COLLECTOR_TOKEN="$1"
ENROLLMENT_TOKEN="${2:-}"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "Erro: Arquivo de configura√ß√£o n√£o encontrado: $CONFIG_FILE"
    exit 1
fi

# Fazer backup
cp "$CONFIG_FILE" "$CONFIG_FILE.backup.$(date +%Y%m%d_%H%M%S)"

# Salvar tokens
if grep -q "^COLLECTOR_TOKEN=" "$CONFIG_FILE"; then
    sed -i "s/^COLLECTOR_TOKEN=.*/COLLECTOR_TOKEN=$COLLECTOR_TOKEN/" "$CONFIG_FILE"
else
    echo "COLLECTOR_TOKEN=$COLLECTOR_TOKEN" >> "$CONFIG_FILE"
fi

if [ -n "$ENROLLMENT_TOKEN" ]; then
    if grep -q "^ENROLLMENT_TOKEN=" "$CONFIG_FILE"; then
        sed -i "s/^ENROLLMENT_TOKEN=.*/ENROLLMENT_TOKEN=$ENROLLMENT_TOKEN/" "$CONFIG_FILE"
    else
        echo "ENROLLMENT_TOKEN=$ENROLLMENT_TOKEN" >> "$CONFIG_FILE"
    fi
fi

echo "Token salvo com sucesso no arquivo $CONFIG_FILE"
echo "COLLECTOR_TOKEN: ${COLLECTOR_TOKEN:0:8}...${COLLECTOR_TOKEN: -8}"
if [ -n "$ENROLLMENT_TOKEN" ]; then
    echo "ENROLLMENT_TOKEN: ${ENROLLMENT_TOKEN:0:8}...${ENROLLMENT_TOKEN: -8}"
fi

# Reiniciar servi√ßo se estiver rodando
if systemctl is-active --quiet samureye-collector; then
    echo "Reiniciando servi√ßo collector para aplicar novo token..."
    systemctl restart samureye-collector
fi
SAVE_TOKEN_EOF

chmod +x "$COLLECTOR_DIR/scripts/save-token.sh"
chown root:root "$COLLECTOR_DIR/scripts/save-token.sh"
log "‚úÖ Script de salvamento de token criado: $COLLECTOR_DIR/scripts/save-token.sh"

# Script de extra√ß√£o robusta de token da API (corre√ß√£o integrada)
cat > "$COLLECTOR_DIR/scripts/extract-token.sh" << 'EXTRACT_TOKEN_EOF'
#!/bin/bash

# Script auxiliar para extrair token de resposta da API
# Tenta m√∫ltiplas formas de extra√ß√£o - CORRE√á√ÉO INTEGRADA VLXSAM04

RESPONSE_BODY="$1"

if [ -z "$RESPONSE_BODY" ]; then
    echo ""
    exit 1
fi

# M√∫ltiplas tentativas de extra√ß√£o
TOKEN=""

# M√©todo 1: jq com m√∫ltiplos caminhos
if command -v jq >/dev/null 2>&1; then
    TOKEN=$(echo "$RESPONSE_BODY" | jq -r '.collector.token // .token // .authToken // .collectorToken // .auth.token // .data.token // ""' 2>/dev/null)
fi

# M√©todo 2: grep com padr√µes diferentes
if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
    TOKEN=$(echo "$RESPONSE_BODY" | grep -o '"token":"[^"]*"' | head -1 | cut -d'"' -f4 2>/dev/null)
fi

if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
    TOKEN=$(echo "$RESPONSE_BODY" | grep -o '"authToken":"[^"]*"' | head -1 | cut -d'"' -f4 2>/dev/null)
fi

if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
    TOKEN=$(echo "$RESPONSE_BODY" | grep -o '"collectorToken":"[^"]*"' | head -1 | cut -d'"' -f4 2>/dev/null)
fi

# M√©todo 3: sed para extra√ß√£o mais agressiva
if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
    TOKEN=$(echo "$RESPONSE_BODY" | sed -n 's/.*"token":"\([^"]*\)".*/\1/p' | head -1)
fi

# M√©todo 4: awk para busca por padr√µes UUID-like
if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
    TOKEN=$(echo "$RESPONSE_BODY" | awk -F'"' '/token.*[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/ {for(i=1;i<=NF;i++) if($i ~ /[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/) print $i}' | head -1)
fi

# Validar se token tem formato v√°lido (UUID ou similar)
if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
    # Verificar se parece com UUID ou token v√°lido (pelo menos 16 caracteres)
    if [ ${#TOKEN} -ge 16 ]; then
        echo "$TOKEN"
        exit 0
    fi
fi

# Nenhum token v√°lido encontrado
echo ""
exit 1
EXTRACT_TOKEN_EOF

chmod +x "$COLLECTOR_DIR/scripts/extract-token.sh"
chown root:root "$COLLECTOR_DIR/scripts/extract-token.sh"
log "‚úÖ Extrator robusto de token criado: $COLLECTOR_DIR/scripts/extract-token.sh"

# Script de diagn√≥stico integrado
cat > "$COLLECTOR_DIR/scripts/check-status.sh" << 'DIAG_EOF'
#!/bin/bash
# Script de diagn√≥stico integrado para vlxsam04

echo "üîç DIAGN√ìSTICO COLLECTOR vlxsam04"
echo "================================"

HOSTNAME=$(hostname)
IP_ADDRESS=$(hostname -I | awk '{print $1}')
API_URL="https://api.samureye.com.br"

echo "üìã Sistema: $HOSTNAME ($IP_ADDRESS)"
echo ""

echo "ü§ñ Status do Servi√ßo:"
systemctl status samureye-collector --no-pager -l

echo ""
echo "üìù Logs Recentes (Heartbeat):"
if [ -f "/var/log/samureye-collector/heartbeat.log" ]; then
    tail -n 15 /var/log/samureye-collector/heartbeat.log
else
    echo "‚ùå Log de heartbeat n√£o encontrado"
fi

echo ""
echo "üîó Teste de Conectividade:"
if timeout 5 bash -c "</dev/tcp/api.samureye.com.br/443" >/dev/null 2>&1; then
    echo "‚úÖ API acess√≠vel (porta 443)"
else
    echo "‚ùå API inacess√≠vel"
fi

if nslookup api.samureye.com.br >/dev/null 2>&1; then
    echo "‚úÖ DNS funcionando"
else
    echo "‚ùå Problema DNS"
fi

echo ""
echo "üìä Configura√ß√£o:"
if [ -f "/etc/samureye-collector/.env" ]; then
    echo "‚úÖ Arquivo .env existe"
    grep -E "^(COLLECTOR_|HOSTNAME|IP_)" /etc/samureye-collector/.env
else
    echo "‚ùå Arquivo .env n√£o encontrado"
fi

if [ -f "/etc/samureye-collector/token.conf" ]; then
    echo "‚úÖ Token existe"
else
    echo "‚ùå Token n√£o encontrado"
fi

echo ""
echo "üîç Recomenda√ß√µes:"
echo "‚Ä¢ Verificar interface: https://app.samureye.com.br/admin/collectors"
echo "‚Ä¢ Monitorar logs: tail -f /var/log/samureye-collector/heartbeat.log"
echo "‚Ä¢ Reiniciar se necess√°rio: systemctl restart samureye-collector"
DIAG_EOF

chmod +x "$COLLECTOR_DIR/scripts/check-status.sh"
chown "$COLLECTOR_USER:$COLLECTOR_USER" "$COLLECTOR_DIR/scripts/check-status.sh"

log "‚úÖ Script de diagn√≥stico integrado criado"

# ============================================================================
# 16. CORRE√á√ÉO AUTOM√ÅTICA DE PROBLEMAS DE AUTENTICA√á√ÉO
# ============================================================================

log "üîß Verificando e corrigindo problemas de autentica√ß√£o..."

# Verificar se existe token corrompido ou problema de autentica√ß√£o
if [ -f "$CONFIG_FILE" ]; then
    # Verificar se h√° logs de erro 401 recentes
    if [ -f "/var/log/samureye-collector/collector.log" ]; then
        RECENT_401_ERRORS=$(grep "401.*Unauthorized" "/var/log/samureye-collector/collector.log" 2>/dev/null | tail -5 | wc -l)
        
        if [ "$RECENT_401_ERRORS" -gt 0 ]; then
            warn "‚ö†Ô∏è Detectados erros 401 Unauthorized recentes ($RECENT_401_ERRORS)"
            log "üîß Aplicando corre√ß√£o autom√°tica..."
            
            # Parar servi√ßo
            if systemctl is-active --quiet "$SERVICE_NAME" 2>/dev/null; then
                systemctl stop "$SERVICE_NAME"
                log "‚úÖ Servi√ßo parado para corre√ß√£o"
            fi
            
            # Limpar token corrompido
            if grep -q "^COLLECTOR_TOKEN=" "$CONFIG_FILE"; then
                sed -i '/^COLLECTOR_TOKEN=/d' "$CONFIG_FILE"
                log "‚úÖ Token corrompido removido"
            fi
            
            # Limpar arquivos de configura√ß√£o problem√°ticos
            rm -f "$COLLECTOR_DIR/config.json" "$COLLECTOR_DIR/.collector_id" "$COLLECTOR_DIR/collector.pid" 2>/dev/null
            
            # Limpar logs com erros
            if [ -f "/var/log/samureye-collector/collector.log" ]; then
                tail -50 "/var/log/samureye-collector/collector.log" > "/var/log/samureye-collector/collector.log.tmp"
                mv "/var/log/samureye-collector/collector.log.tmp" "/var/log/samureye-collector/collector.log"
                log "‚úÖ Logs com erros limpos"
            fi
            
            # Criar instru√ß√µes de re-registro
            cat > "$COLLECTOR_DIR/REREGISTER_REQUIRED.txt" << 'REREG_EOF'
‚ùó CORRE√á√ÉO APLICADA - RE-REGISTRO NECESS√ÅRIO
================================================

Problema detectado: Erros 401 Unauthorized
Corre√ß√£o aplicada: Token corrompido removido

üîÑ PARA REATIVAR O COLLECTOR:

1. Crie NOVO collector na interface:
   https://app.samureye.com.br/admin/collectors

2. Execute comando de registro:
   curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/register-collector.sh | bash -s -- <tenant-slug> <enrollment-token>

3. Collector voltar√° automaticamente para ONLINE

REREG_EOF
            
            chown "$COLLECTOR_USER:$COLLECTOR_USER" "$COLLECTOR_DIR/REREGISTER_REQUIRED.txt"
            
            warn "‚ö†Ô∏è Corre√ß√£o aplicada - RE-REGISTRO NECESS√ÅRIO"
            echo "   ‚Ä¢ Instru√ß√µes salvas em: $COLLECTOR_DIR/REREGISTER_REQUIRED.txt"
            echo "   ‚Ä¢ Collector n√£o iniciar√° automaticamente"
            echo "   ‚Ä¢ Execute register-collector.sh com novo token"
            
        else
            log "‚úÖ Nenhum erro de autentica√ß√£o detectado"
        fi
    fi
fi

# Criar script de diagn√≥stico espec√≠fico para problemas 401
cat > "$COLLECTOR_DIR/scripts/diagnose-401-issue.sh" << 'DIAG401_EOF'
#!/bin/bash
# Diagn√≥stico r√°pido para problemas 401 Unauthorized
echo "üîç Verificando problema 401 Unauthorized..."
echo ""

if [ -f "/var/log/samureye-collector/collector.log" ]; then
    ERRORS_401=$(grep "401.*Unauthorized" "/var/log/samureye-collector/collector.log" 2>/dev/null | wc -l)
    echo "Erros 401 encontrados: $ERRORS_401"
    
    if [ "$ERRORS_401" -gt 0 ]; then
        echo ""
        echo "‚ö†Ô∏è PROBLEMA CONFIRMADO: Collector com erro de autentica√ß√£o"
        echo ""
        echo "üîß SOLU√á√ÉO:"
        echo "   curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/fix-collector-401-issue.sh | bash"
        echo ""
    else
        echo "‚úÖ Nenhum erro 401 encontrado"
    fi
else
    echo "‚ö†Ô∏è Log file n√£o encontrado"
fi
DIAG401_EOF

chmod +x "$COLLECTOR_DIR/scripts/diagnose-401-issue.sh"
chown "$COLLECTOR_USER:$COLLECTOR_USER" "$COLLECTOR_DIR/scripts/diagnose-401-issue.sh"

log "‚úÖ Sistema de corre√ß√£o autom√°tica integrado"

# ============================================================================
# 16.1. CORRE√á√ÉO FINAL: GARANTIR FUNCIONAMENTO AP√ìS INSTALA√á√ÉO  
# ============================================================================

log "üîß Verifica√ß√£o e corre√ß√£o final do status do servi√ßo..."

# Verificar se arquivo .env existe
if [ ! -f "$CONFIG_FILE" ]; then
    warn "‚ùå Arquivo .env ausente ap√≥s instala√ß√£o - criando..."
    
    cat > "$CONFIG_FILE" << CONFIG_EOF
# Configura√ß√£o do Collector SamurEye - P√≥s Instala√ß√£o
COLLECTOR_ID=$HOSTNAME
COLLECTOR_NAME=$HOSTNAME
HOSTNAME=$HOSTNAME
IP_ADDRESS=$(hostname -I | awk '{print $1}')
SAMUREYE_API_URL=$API_SERVER
HEARTBEAT_INTERVAL=30
RETRY_ATTEMPTS=3
RETRY_DELAY=5
LOG_LEVEL=INFO

# Tokens de autentica√ß√£o (ser√£o preenchidos durante registro)
COLLECTOR_TOKEN=
ENROLLMENT_TOKEN=

# Status do collector
STATUS=offline

# Configura√ß√µes adicionais
VERIFY_SSL=false
TIMEOUT=30
MAX_RETRIES=5
CONFIG_EOF

    chown root:"$COLLECTOR_USER" "$CONFIG_FILE"
    chmod 640 "$CONFIG_FILE"
    log "‚úÖ Arquivo .env criado automaticamente"
else
    log "‚úÖ Arquivo .env existe"
fi

# Verificar e corrigir permiss√µes finais
log "üîß Aplicando permiss√µes finais..."
chown -R root:root /opt/samureye/collector 2>/dev/null || true
chown -R root:"$COLLECTOR_USER" /etc/samureye-collector 2>/dev/null || true
chown -R "$COLLECTOR_USER":"$COLLECTOR_USER" /var/log/samureye-collector 2>/dev/null || true
chmod -R 755 /opt/samureye/collector 2>/dev/null || true
chmod -R 750 /etc/samureye-collector 2>/dev/null || true
chmod -R 755 /var/log/samureye-collector 2>/dev/null || true
if [ -f "$CONFIG_FILE" ]; then
    chmod 640 "$CONFIG_FILE"
fi
log "‚úÖ Permiss√µes finais aplicadas"

# Recarregar systemd e tentar iniciar servi√ßo
systemctl daemon-reload
systemctl enable "$SERVICE_NAME" 2>/dev/null || true

# Tentar iniciar servi√ßo com mais tentativas
RETRY_START=0
MAX_START_RETRIES=3

while [ $RETRY_START -lt $MAX_START_RETRIES ]; do
    if systemctl start "$SERVICE_NAME" 2>/dev/null; then
        log "‚úÖ Servi√ßo iniciado (tentativa $((RETRY_START + 1)))"
        sleep 5
        
        if systemctl is-active --quiet "$SERVICE_NAME"; then
            log "‚úÖ Servi√ßo est√° rodando corretamente"
            
            # Verificar se est√° gerando logs
            sleep 3
            if [ -f "/var/log/samureye-collector/heartbeat.log" ] || [ -f "/var/log/samureye-collector/collector.log" ]; then
                log "‚úÖ Sistema funcionando - logs sendo gerados"
            else
                log "‚ÑπÔ∏è Servi√ßo rodando - aguardando gera√ß√£o de logs"
            fi
            break
        else
            warn "‚ö†Ô∏è Servi√ßo n√£o est√° ativo ap√≥s inicializa√ß√£o (tentativa $((RETRY_START + 1)))"
            RETRY_START=$((RETRY_START + 1))
            
            if [ $RETRY_START -lt $MAX_START_RETRIES ]; then
                log "üîÑ Tentando novamente em 3 segundos..."
                sleep 3
                systemctl daemon-reload
            fi
        fi
    else
        warn "‚ö†Ô∏è Falha ao iniciar servi√ßo (tentativa $((RETRY_START + 1)))"
        RETRY_START=$((RETRY_START + 1))
        
        if [ $RETRY_START -lt $MAX_START_RETRIES ]; then
            log "üîÑ Tentando novamente..."
            sleep 2
        fi
    fi
done

if [ $RETRY_START -eq $MAX_START_RETRIES ]; then
    warn "‚ö†Ô∏è Servi√ßo n√£o conseguiu iniciar ap√≥s $MAX_START_RETRIES tentativas"
    log "üìã Use diagn√≥stico para identificar problema:"
    log "   curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/diagnose-current-status.sh | bash"
fi

# ============================================================================
# 17. INFORMA√á√ïES FINAIS
# ============================================================================

echo ""
log "üéâ HARD RESET DO COLLECTOR AGENT CONCLU√çDO!"
echo ""
echo "üìã RESUMO DA INSTALA√á√ÉO:"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "ü§ñ Collector Agent:"
echo "   ‚Ä¢ Status:  $(systemctl is-active $SERVICE_NAME)"
echo "   ‚Ä¢ User:    $COLLECTOR_USER"
echo "   ‚Ä¢ Dir:     $COLLECTOR_DIR"
echo "   ‚Ä¢ Logs:    /var/log/samureye-collector/"
echo ""
echo "üêç Python $PYTHON_VERSION:"
echo "   ‚Ä¢ Version: $(python --version)"
echo "   ‚Ä¢ Libs:    psutil, requests"
echo ""
echo "üì¶ Node.js $NODE_VERSION:"
echo "   ‚Ä¢ Version: $(node --version)"
echo ""
echo "üõ°Ô∏è Security Tools:"
echo "   ‚Ä¢ Nmap:     $(command -v nmap >/dev/null && echo "‚úÖ Instalado" || echo "‚ùå Ausente")"
echo "   ‚Ä¢ Nuclei:   $(command -v nuclei >/dev/null && echo "‚úÖ Instalado" || echo "‚ùå Ausente")"
echo "   ‚Ä¢ Masscan:  $(command -v masscan >/dev/null && echo "‚úÖ Instalado" || echo "‚ùå Ausente")"
echo "   ‚Ä¢ Gobuster: $(command -v gobuster >/dev/null && echo "‚úÖ Instalado" || echo "‚ùå Ausente")"
echo ""
echo "üîß Comandos √öteis:"
echo "   ‚Ä¢ Status:     systemctl status $SERVICE_NAME"
echo "   ‚Ä¢ Logs:       tail -f /var/log/samureye-collector/collector.log"
echo "   ‚Ä¢ Restart:    systemctl restart $SERVICE_NAME"
echo "   ‚Ä¢ Heartbeat:  $COLLECTOR_DIR/heartbeat.py"
echo "   ‚Ä¢ Cleanup:    $COLLECTOR_DIR/scripts/cleanup.sh"
echo "   ‚Ä¢ Test Conn:  $COLLECTOR_DIR/test-connectivity.sh"
echo "   ‚Ä¢ Check Status: $COLLECTOR_DIR/scripts/check-status.sh"
echo ""
echo "üîó Conectividade:"
echo "   ‚Ä¢ API:       $API_SERVER"
echo "   ‚Ä¢ Gateway:   $GATEWAY_SERVER"
echo ""
echo "üíì Heartbeat & Status:"
echo "   ‚Ä¢ Intervalo: 30 segundos (configur√°vel em $CONFIG_FILE)"
echo "   ‚Ä¢ Endpoint:  https://api.samureye.com.br/collector-api/heartbeat"
echo "   ‚Ä¢ Retry:     3 tentativas autom√°ticas por request"
echo "   ‚Ä¢ Timeout:   30 segundos por request HTTP"
echo ""
echo "üìù PR√ìXIMOS PASSOS OBRIGAT√ìRIOS:"
echo "   ‚ö†Ô∏è  SISTEMA BASE INSTALADO - REGISTRO NECESS√ÅRIO ‚ö†Ô∏è"
echo ""
echo "   1. Acesse a interface de administra√ß√£o:"
echo "      https://app.samureye.com.br/admin/collectors"
echo ""
echo "   2. Fa√ßa login e v√° para 'Gest√£o de Coletores'"
echo ""
echo "   3. Clique em 'Novo Coletor' e preencha:"
echo "      ‚Ä¢ Nome: $HOSTNAME"
echo "      ‚Ä¢ Hostname: $HOSTNAME"
echo "      ‚Ä¢ IP: $(hostname -I | awk '{print $1}')"
echo ""
echo "   4. Copie o TOKEN DE ENROLLMENT gerado (v√°lido por 15 minutos)"
echo ""
echo "   5. Execute o comando de registro:"
echo "      curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/register-collector.sh | bash -s -- <tenant-slug> <enrollment-token>"
echo ""
echo "   üìå EXEMPLO:"
echo "      curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/register-collector.sh | bash -s -- gruppen-it abc123-def456-ghi789"
echo ""
echo "‚úÖ AP√ìS O REGISTRO:"
echo "   ‚Ä¢ Collector aparecer√° como 'ONLINE' na interface"
echo "   ‚Ä¢ Logs: tail -f /var/log/samureye-collector/heartbeat.log"
echo "   ‚Ä¢ Status: $COLLECTOR_DIR/scripts/check-status.sh"
echo ""
echo "üîß COMANDOS DISPON√çVEIS:"
echo "   ‚Ä¢ Instalar sistema base:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/install-hard-reset.sh | bash"
echo ""
echo "   ‚Ä¢ Registrar collector (ap√≥s criar na interface):"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/register-collector.sh | bash -s -- <tenant-slug> <token>"
echo ""
echo "   ‚Ä¢ Verificar status:"
echo "     $COLLECTOR_DIR/scripts/check-status.sh"
echo ""
echo "üîç DIAGN√ìSTICO E CORRE√á√ÉO:"
echo "   ‚Ä¢ Diagn√≥stico problema 401 Unauthorized:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/diagnose-collector-401-unauthorized.sh | bash"
echo ""
echo "   ‚Ä¢ Corre√ß√£o problema 401 Unauthorized:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/fix-collector-401-issue.sh | bash"
echo ""
echo "   ‚Ä¢ Diagn√≥stico auto-registro ap√≥s exclus√£o:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/diagnose-collector-auto-register.sh | bash"
echo ""
echo "   ‚Ä¢ Corre√ß√£o ap√≥s exclus√£o do collector:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/fix-collector-after-deletion.sh | bash"
echo ""
echo "   ‚Ä¢ Diagn√≥stico desconex√£o registro vs servi√ßo:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/diagnose-token-disconnect.sh | bash"
echo ""
echo "   ‚Ä¢ Corre√ß√£o desconex√£o registro vs servi√ßo:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/fix-token-disconnect.sh | bash"
echo ""
echo "   ‚Ä¢ Diagn√≥stico permiss√µes e salvamento token:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/diagnose-permissions-token-save.sh | bash"
echo ""
echo "   ‚Ä¢ Corre√ß√£o permiss√µes e salvamento token:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/fix-permissions-token-save.sh | bash"
echo ""
echo "   ‚Ä¢ Diagn√≥stico resposta API token:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/diagnose-api-token-response.sh | bash -s -- gruppen-it <TOKEN>"
echo ""
echo "   ‚Ä¢ Corre√ß√£o extra√ß√£o de token da API:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/fix-api-token-extraction.sh | bash"
echo ""
echo "üéØ CORRE√á√ïES INTEGRADAS (COLLECTOR_ID CORRIGIDO):"
echo "   ‚úÖ Extra√ß√£o robusta de token no register-collector.sh"
echo "   ‚úÖ Heartbeat corrigido usa collector_id (n√£o collectorId)"
echo "   ‚úÖ API 400 'collector_id required' resolvido"
echo ""
echo "üîç DIAGN√ìSTICO ATUAL (se ainda h√° problemas):"
echo "   ‚Ä¢ Diagn√≥stico completo do status atual:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/diagnose-current-status.sh | bash"
echo ""
echo "   ‚Ä¢ Corre√ß√£o de problemas atuais:"
echo "     curl -fsSL https://raw.githubusercontent.com/GruppenIT/SamurEye/main/docs/deployment/vlxsam04/fix-current-issues.sh | bash"
echo ""
echo "   ‚Ä¢ Diagn√≥stico r√°pido local:"
echo "     $COLLECTOR_DIR/scripts/check-status.sh"
echo ""
echo "   ‚Ä¢ Salvar token manualmente (se necess√°rio):"
echo "     $COLLECTOR_DIR/scripts/save-token.sh <collector-token>"
echo ""
echo "üí° CORRE√á√ïES INTEGRADAS NO INSTALL-HARD-RESET:"
echo "   ‚úÖ Usu√°rio com permiss√µes corretas"
echo "   ‚úÖ Arquivo .env com permiss√µes 640 (root:collector)"
echo "   ‚úÖ Permiss√µes de log corrigidas automaticamente"
echo "   ‚úÖ Servi√ßo systemd configurado para usu√°rio samureye-collector"
echo "   ‚úÖ Script de salvamento de token integrado"
echo "   ‚úÖ Extrator robusto de token da API integrado"
echo "   ‚úÖ Teste de permiss√µes autom√°tico durante instala√ß√£o"
echo "   ‚úÖ Heartbeat corrigido - usa collector_id (n√£o collectorId)"
echo "   ‚úÖ Extra√ß√£o robusta de token em register-collector.sh"
echo "   ‚úÖ Corre√ß√£o autom√°tica de arquivo .env ausente"
echo "   ‚úÖ Verifica√ß√£o e corre√ß√£o final do status do servi√ßo"
echo "   ‚úÖ M√∫ltiplas tentativas de inicializa√ß√£o do servi√ßo"
echo "   ‚úÖ CORRE√á√ÉO CR√çTICA - Heartbeat usa COLLECTOR_TOKEN do registro externo"
echo "   ‚úÖ Eliminada desconex√£o entre registro externo e heartbeat interno"
echo "   ‚úÖ Warning SSL suprimido para logs mais limpos"
echo ""

exit 0